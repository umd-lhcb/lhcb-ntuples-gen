`babymaker` was original conceived by Manuel Franco Sevilla and his colleagues
at UCSB[^1]. It was later rewritten by Yipeng Sun to make it simpler[^2].

`babymaker` takes a `.root` file, and producing a new `.root` file by:

* renaming,
* making selections
* dropping
* doing additional calculations

on selected branches of the input `.root` file.

!!! warning
    Please use `clang-format` to reformat all `c++` code before commit. To do
    so, go th the `<project_root>`, and:
    ```
    clang-format -i <path_to_cpp_file>
    ```


[^1]: The original `babymaker` project can be found [here](https://github.com/manuelfs/babymaker).
[^2]: The original one uses `c++` to write `c++`, the new one uses `Python` to
      write `c++`. Also, the tree structures of the `.root` files are
      semi-automatically detected by the new `babymaker.py`.


## Detect `.root` file tree structure
This is done by the auxiliary `c++` program `tuple_dump`, with its source located at:
```
<project_root>/src/tuple_dump.cpp
```

`tuple_dump` usage is very simple:
```
usage: tuple_dump [INPUT ROOT FILE] [OUTPUT YAML ROOT FILE TREE STRUCTURE]
```


## Use `babymaker.py` to generate `c++` file
`babymaker.py` takes a `YAML` file that specify the output `.root` file tree
structure, as well as the `YAML` file generated by the `tuple_dump` on the
input `.root` file, so that it understands the tree structure of the input file.

You also need to specify the output location of the `c++` file. After compiling
the `c++` file, it will generate the output `.root` file.

`babymaker` usage is listed below:
```
usage: babymaker.py [-h] -g [{PostProcess,Compare}] [-i [INPUT]] -o [OUTPUT]
                    [-d [DATATYPE]] [-H HEADERS [HEADERS ...]]

generate compilable C++ source file for ntuple processing.

optional arguments:
  -h, --help            show this help message and exit
  -g [{PostProcess,Compare}], --generator [{PostProcess,Compare}]
                        choose a C++ code generator.
  -i [INPUT], --input [INPUT]
                        path to input YAML file.
  -o [OUTPUT], --output [OUTPUT]
                        path to output C++ file.
  -d [DATATYPE], --datatype [DATATYPE]
                        path to ntuple datatype YAML file.
  -H HEADERS [HEADERS ...], --headers HEADERS [HEADERS ...]
                        additional headers to be included in generated C++.
```

You can take a look at `Makefile` to see how we glue `tuple_dump` and
`babymaker.py` together.

Finally, we list a sample `YAML` file for output `.root` file tree structure:
```yaml
ATuple:
    force_lowercase: false
    input:
        - TupleY/DecayTree
    keep:
        - ^Y_P\w$
    rename:
        Y_PT: y_pt
        Y_PX: y_px
        Y_PY: y_py
        Y_PZ: y_pz
        selection:
    Y_PT: "> 10000"

AnotherTuple:
    force_lowercase: true
    headers:
        - cmath
    input:
        - TupleY/DecayTree
    keep:
        - Y_P.*
    selection:
        Y_PT: "> 10000"
        Y_PE: "> (100 * pow(10, 3))"

YetAnotherTuple:
    force_lowercase: true
    headers:
        - cmath
    input:
        - TupleY/DecayTree
        - TupleYWSPi/DecayTree
    # Drop arrays. We don't support them (yet).
    drop:
        - Y_OWNPV_COV_
    keep:
        - Y_OWNPV_.*
        - Y_ISOLATION_.*

YetYetAnotherTuple:
    force_lowercase: true
    headers:
        - functor/basic.h
    input:
        - TupleY/DecayTree
    drop:
        - Y_PE
    keep:
        - Y_P.*
    selection:
        Y_PT: "> 10000"
    calculation:
        SUM: "SUM(Y_PE, Y_P)"
```

!!! note
    The `drop` section will always execute before `keep`. Also, they both fully
    utilize regualr expressions so the expressons.
    `Y_P*` should not be used in most cases.
