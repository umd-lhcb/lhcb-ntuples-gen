headers:
    user:
        - functor/rdx/cut.h
        - functor/rdx/kinematic.h
        - functor/basic.h

keep:
    # Event uid, also needed for keeping only one B for multi-B events
    - runNumber
    - eventNumber
    - GpsTime
    - mu_bdt_mu

rename:
    # For pseudo-random sequence generation
    b0_PT: prs_in
    b_PT: prs_in

    #######################
    # Isolation variables #
    #######################
    b0_ISOLATION_BDT: iso_bdt1
    b0_ISOLATION_BDT2: iso_bdt2
    b0_ISOLATION_BDT3: iso_bdt3

    b_ISOLATION_BDT: iso_bdt1
    b_ISOLATION_BDT2: iso_bdt2
    b_ISOLATION_BDT3: iso_bdt3

    # PID from isolation
    b0_ISOLATION_NNk: iso_nnk1
    b0_ISOLATION_NNk2: iso_nnk2
    b0_ISOLATION_NNk3: iso_nnk3

    b_ISOLATION_NNk: iso_nnk1
    b_ISOLATION_NNk2: iso_nnk2
    b_ISOLATION_NNk3: iso_nnk3

    # Charge from isolation:
    b0_ISOLATION_CHARGE: iso_chrg1
    b0_ISOLATION_CHARGE2: iso_chrg2

    b_ISOLATION_CHARGE: iso_chrg1
    b_ISOLATION_CHARGE2: iso_chrg2

calculation:
    #######################
    # Isolation variables #
    #######################
    # Kinematic from isolation
    iso_p1: float; GEV(MAG(b0_ISOLATION_PX, b0_ISOLATION_PY, b0_ISOLATION_PZ)); GEV(MAG(b_ISOLATION_PX, b_ISOLATION_PY, b_ISOLATION_PZ))
    iso_pt1: float; GEV(MAG(b0_ISOLATION_PX, b0_ISOLATION_PY)); GEV(MAG(b_ISOLATION_PX, b_ISOLATION_PY))

    #################
    # Fit variables #
    #################
    el: double; GEV(FitVar_El)
    mm2: double; GEV2(FitVar_Mmiss2)
    q2: double; GEV2(FitVar_q2)

    #######################
    # Kinematic variables #
    #######################
    # B0
    b0_m: double; GEV(b0_M)
    b0_p: double; GEV(b0_P)
    b0_pt: double; GEV(b0_PT)
    # B
    b_m: double; GEV(b_M)
    b_p: double; GEV(b_P)
    b_pt: double; GEV(b_PT)

    # D*
    dst_m: double; GEV(dst_M)
    dst_p: double; GEV(dst_P)
    dst_pt: double; GEV(dst_PT)
    # slow Pi
    spi_p: double; GEV(spi_P)
    spi_pt: double; GEV(spi_PT)

    # D0
    d0_m: double; GEV(d0_M)
    d0_p: double; GEV(d0_P)
    d0_pt: double; GEV(d0_PT)
    # K
    k_p: double; GEV(k_P)
    k_pt: double; GEV(k_PT)
    # Pi
    pi_p: double; GEV(pi_P)
    pi_pt: double; GEV(pi_PT)

    # Mu
    mu_p: double; GEV(mu_P)
    mu_pt: double; GEV(mu_PT)

    #################
    # PID variables #
    #################
    # K
    k_is_mu: k_isMuon
    k_pid_mu: k_PIDmu
    k_pid_k: k_PIDK
    k_pid_e: k_PIDe
    # Mu
    mu_is_mu: mu_isMuon
    mu_pid_mu: mu_PIDmu
    mu_pid_k: mu_PIDK
    mu_pid_e: mu_PIDe
    # Pi
    pi_is_mu: pi_isMuon
    pi_pid_mu: pi_PIDmu
    pi_pid_k: pi_PIDK
    pi_pid_e: pi_PIDe
    # Slow Pi
    spi_is_mu: spi_isMuon
    spi_pid_mu: spi_PIDmu
    spi_pid_k: spi_PIDK
    spi_pid_e: spi_PIDe

    ############
    # Triggers #
    ############
    b0_l0_global_tis: bool; b0_L0Global_TIS
    b_l0_global_tis: bool; b_L0Global_TIS
    d0_l0_haddron_tos: bool; d0_L0HadronDecision_TOS
    k_hlt1_trackmva_tos: bool; k_Hlt1TrackMVADecision_TOS
    pi_hlt1_trackmva_tos: bool; pi_Hlt1TrackMVADecision_TOS
    d0_hlt1_twotrackmva_tos: bool; d0_Hlt1TwoTrackMVADecision_TOS
    b0_hlt2_tos: bool; b0_Hlt2XcMuXForTauB2XcMuDecision_TOS
    b_hlt2_tos: bool; b_Hlt2XcMuXForTauB2XcMuDecision_TOS

    ###################
    # Selection flags #
    ###################
    # Trigger
    flag_l0: "bool; b0_L0Global_TIS || d0_L0HadronDecision_TOS; b_L0Global_TIS || d0_L0HadronDecision_TOS"
    flag_hlt1: "bool; k_Hlt1TrackMVADecision_TOS || pi_Hlt1TrackMVADecision_TOS || d0_Hlt1TwoTrackMVADecision_TOS"
    flag_hlt2: "bool; b0_Hlt2XcMuXForTauB2XcMuDecision_TOS; b_Hlt2XcMuXForTauB2XcMuDecision_TOS"

    # D0 selection
    flag_d0_pid_ok: bool; FLAG_SEL_D0_PID_OK_RUN1(k_PIDK, pi_PIDK, k_isMuon, pi_isMuon)
    flag_d0: >-
        bool; FLAG_SEL_D0_RUN1(
        flag_d0_pid_ok,
        k_PT, pi_PT, k_P, pi_P,
        k_Hlt1TrackMVADecision_TOS, pi_Hlt1TrackMVADecision_TOS,
        k_IPCHI2_OWNPV, pi_IPCHI2_OWNPV,
        k_TRACK_GhostProb, pi_TRACK_GhostProb,
        d0_PT, true,
        d0_ENDVERTEX_NDOF, d0_ENDVERTEX_CHI2,
        d0_IP_OWNPV, d0_IPCHI2_OWNPV,
        d0_DIRA_OWNPV, d0_FDCHI2_OWNPV, d0_M
        )

    # Variables needed for Mu selection
    trk_mu:  ^XYZVector; XYZVector(mu_PX, mu_PY, mu_PZ)
    trk_k:   ^XYZVector; XYZVector(k_PX, k_PY, k_PZ)
    trk_pi:  ^XYZVector; XYZVector(pi_PX, pi_PY, pi_PZ)
    trk_spi: ^XYZVector; XYZVector(spi_PX, spi_PY, spi_PZ)
    other_trks: ^vector<XYZVector>; BUILD_VEC(trk_k, trk_pi, trk_spi); BUILD_VEC(trk_k, trk_pi)
    mu_eta: double; ETA(mu_P, mu_PZ)
    # Mu selection
    flag_good_trks: bool; FLAG_SEL_GOOD_TRACKS(trk_mu, other_trks)
    flag_mu_pid_ok: bool; FLAG_SEL_MU_PID_OK_RUN1(mu_isMuon, mu_PIDmu, mu_PIDe, mu_bdt_mu)
    flag_mu: >-
        bool; FLAG_SEL_MU_RUN1(
        flag_good_trks, flag_mu_pid_ok,
        mu_P, mu_eta,
        mu_IPCHI2_OWNPV, mu_TRACK_GhostProb
        )

    # D0Mu combo selection
    b_fd_trans: double; FD_TRANS(b_ENDVERTEX_X, b_OWNPV_X, b_ENDVERTEX_Y, b_OWNPV_Y)
    flag_d0mu: >-
        bool; FLAG_SEL_BMINUSD0_RUN1(
        flag_d0, flag_mu,
        b_ENDVERTEX_CHI2, b_ENDVERTEX_NDOF,
        b_fd_trans,
        b_DIRA_OWNPV,
        b_M,
        mu_PX, mu_PY, mu_PZ,
        d0_PX, d0_PY, d0_PZ, d0_M
        )

    # D*Mu combo selection
    b0_fd_trans: double; FD_TRANS(b0_ENDVERTEX_X, b0_OWNPV_X, b0_ENDVERTEX_Y, b0_OWNPV_Y)
    flag_dstmu: >-
        bool; FLAG_SEL_B0DST_RUN1(
        flag_d0, flag_mu,
        spi_TRACK_GhostProb,
        dst_ENDVERTEX_CHI2, dst_ENDVERTEX_NDOF,
        dst_M, d0_M,
        b0_ENDVERTEX_CHI2, b0_ENDVERTEX_NDOF,
        b0_fd_trans,
        b0_DIRA_OWNPV, b0_M
        )

global_selection:
    # Trigger (L0, HLT1, HLT2)
    - flag_l0
    - flag_hlt1
    - flag_hlt2
    # Offline cuts
    - flag_d0mu
    - flag_dstmu

one_cand_only:
    enable: true
    branch: rename_prs_in

output:
    # main trees
    Dst:
        input: TupleB0/DecayTree
        selection:
            - "true"
    D0:
        input: TupleBminus/DecayTree
        selection:
            - "true"

    # "skims"
    Dst_iso:
        input: TupleB0/DecayTree
        selection:
            - "iso_bdt1 < 0.15"
    Dst_DD:
        input: TupleB0/DecayTree
        selection:
            - "iso_bdt1 > 0.15"
            - "MAX(iso_nnk1, iso_nnk2, iso_nnk3) > 0.2"
    Dst_1os:
        input: TupleB0/DecayTree
        selection:
            - "iso_bdt1 > 0.15"
            - "iso_bdt2 < 0.15"
            - "iso_nnk1 < 0.2"
            - "iso_p1 > 5"
            - "iso_pt1 > 0.15"
    Dst_Dstst:
        input: TupleB0/DecayTree
        selection:
            - "iso_bdt1 > 0.15"
            - "iso_bdt2 < 0.15"
            - "iso_nnk1 < 0.2"
            - "iso_p1 > 5"
            - "iso_pt1 > 0.15"
            - "2400 < d0_M+pi_M && d0_M+pi_M > 2520"
    Dst_2os:
        input: TupleB0/DecayTree
        selection:
            - "iso_bdt1 > 0.15"
            - "iso_bdt2 > 0."
            - "iso_bdt3 < 0."
            - "iso_chrg1+iso_chrg2 == 0"
            - "iso_nnk1 < 0.2"

    D0_iso:
        input: TupleBminus/DecayTree
        selection:
            - "iso_bdt1 < 0.15"
    D0_DD:
        input: TupleBminus/DecayTree
        selection:
            - "iso_bdt1 > 0.15"
            - "MAX(iso_nnk1, iso_nnk2, iso_nnk3) > 0.2"
    D0_1os:
        input: TupleBminus/DecayTree
        selection:
            - "iso_bdt1 > 0.15"
            - "iso_bdt2 < 0.15"
            - "iso_nnk1 < 0.2"
            - "iso_p1 > 5"
            - "iso_pt1 > 0.15"
    D0_Dstst:
        input: TupleBminus/DecayTree
        selection:
            - "iso_bdt1 > 0.15"
            - "iso_bdt2 < 0.15"
            - "iso_nnk1 < 0.2"
            - "iso_p1 > 5"
            - "iso_pt1 > 0.15"
            - "2400 < d0_M+pi_M && d0_M+pi_M > 2520"
    D0_2os:
        input: TupleBminus/DecayTree
        selection:
            - "iso_bdt1 > 0.15"
            - "iso_bdt2 > 0."
            - "iso_bdt3 < 0."
            - "iso_chrg1+iso_chrg2 == 0"
            - "iso_nnk1 < 0.2"
            - "iso_nnk2 < 0.2"
            - "iso_nnk2 < 0.2"
