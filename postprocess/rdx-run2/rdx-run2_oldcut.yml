headers:
    user:
        - functor/rdx/cut.h
        - functor/rdx/skims.h
        - functor/rdx/kinematic.h
        - functor/rdx/truth_match.h
        - functor/basic.h

keep:
    - runNumber
    - eventNumber
    - GpsTime
    - "^wpid*"
    - "^wtrk*"
    - "^wff"
    - ".*_tos_emu$"
    - "^is_misid_*"
    - "b_m_smr_k"
    - "b_m_smr_pi"

rename:
    # General
    Polarity: polarity
    runNumber: run
    eventNumber: event
    # L0
    b0_L0Global_TIS: b_l0_global_tis
    b_L0Global_TIS: b_l0_global_tis
    d0_L0HadronDecision_TOS: d0_l0_hadron_tos
    # HLT1
    d0_Hlt1TwoTrackMVADecision_TOS: d0_hlt1_twotrackmva_tos
    k_Hlt1TrackMVADecision_TOS: k_hlt1_trackmva_tos
    pi_Hlt1TrackMVADecision_TOS: pi_hlt1_trackmva_tos
    # HLT2
    b0_Hlt2XcMuXForTauB2XcMuDecision_TOS: b_hlt2_tos
    b0_Hlt2XcMuXForTauB2XcFakeMuDecision_TOS: b_hlt2_fakeline_tos
    b_Hlt2XcMuXForTauB2XcMuDecision_TOS: b_hlt2_tos
    b_Hlt2XcMuXForTauB2XcFakeMuDecision_TOS: b_hlt2_fakeline_tos
    # Event variables
    nTracks: ntracks
    NumSPDHits: nspdhits

calculation:
    # For pseudo-random sequence generation
    prs_in: double; b0_PT; b_PT

    #######################
    # Isolation variables #
    #######################
    # Isolation BDTs
    iso_bdt1: double; b0_ISOLATION_BDT;  b_ISOLATION_BDT
    iso_bdt2: double; b0_ISOLATION_BDT2; b_ISOLATION_BDT2
    iso_bdt3: double; b0_ISOLATION_BDT3; b_ISOLATION_BDT3
    # PID
    iso_nnk1: float; b0_ISOLATION_NNk; b_ISOLATION_NNk
    iso_nnk2: float; b0_ISOLATION_NNk2; b_ISOLATION_NNk2
    iso_nnk3: float; b0_ISOLATION_NNk3; b_ISOLATION_NNk3
    iso_nnp1: float; b0_ISOLATION_NNp; b_ISOLATION_NNp
    # ID
    iso_true_id1: int; b0_ISOLATION_TRUEID; b_ISOLATION_TRUEID
    iso_true_id2: int; b0_ISOLATION_TRUEID2; b_ISOLATION_TRUEID2
    iso_true_id3: int; b0_ISOLATION_TRUEID3; b_ISOLATION_TRUEID3
    # Charge
    iso_chrg1: int; b0_ISOLATION_CHARGE;  b_ISOLATION_CHARGE
    iso_chrg2: int; b0_ISOLATION_CHARGE2; b_ISOLATION_CHARGE2
    # Kinematic
    iso_p1: float; GEV(MAG(b0_ISOLATION_PX, b0_ISOLATION_PY, b0_ISOLATION_PZ)); GEV(MAG(b_ISOLATION_PX, b_ISOLATION_PY, b_ISOLATION_PZ))
    iso_p2: float; GEV(MAG(b0_ISOLATION_PX2, b0_ISOLATION_PY2, b0_ISOLATION_PZ2)); GEV(MAG(b_ISOLATION_PX2, b_ISOLATION_PY2, b_ISOLATION_PZ2))
    iso_p3: float; GEV(MAG(b0_ISOLATION_PX3, b0_ISOLATION_PY3, b0_ISOLATION_PZ3)); GEV(MAG(b_ISOLATION_PX3, b_ISOLATION_PY3, b_ISOLATION_PZ3))
    iso_pt1: float; GEV(MAG(b0_ISOLATION_PX, b0_ISOLATION_PY)); GEV(MAG(b_ISOLATION_PX, b_ISOLATION_PY))
    iso_pt2: float; GEV(MAG(b0_ISOLATION_PX2, b0_ISOLATION_PY2)); GEV(MAG(b_ISOLATION_PX2, b_ISOLATION_PY2))
    iso_pt3: float; GEV(MAG(b0_ISOLATION_PX3, b0_ISOLATION_PY3)); GEV(MAG(b_ISOLATION_PX3, b_ISOLATION_PY3))
    # Track types
    iso_type1: int; b0_ISOLATION_Type; b_ISOLATION_Type
    iso_type2: int; b0_ISOLATION_Type2; b_ISOLATION_Type2
    iso_type3: int; b0_ISOLATION_Type3; b_ISOLATION_Type3

    #################
    # Fit variables #
    #################
    # Make all fit variables in GeV
    mm2: double; GEV2(FitVar_Mmiss2)
    q2: double; GEV2(FitVar_q2)
    el: double; GEV(FitVar_El)
    # K,pi-smeared fit variables
    # we'll always have them to make template building eaiser
    mm2_smr_pi: double; mm2_smr_pi; -100.0
    q2_smr_pi: double; q2_smr_pi; -100.0
    el_smr_pi: double; el_smr_pi; -100.0
    mm2_smr_k: double; mm2_smr_k; -100.0
    q2_smr_k: double; q2_smr_k; -100.0
    el_smr_k: double; el_smr_k; -100.0

    #######################
    # Kinematic variables #
    #######################
    # Keep masses in MeV, everything else in GeV
    # B/B0
    b_m: double; b_M; b0_M
    b_p: double; GEV(b_P); GEV(b0_P)
    b_pt: double; GEV(b_PT); GEV(b0_PT)
    b_eta: double; ETA(b_P, b_PZ); ETA(b0_P, b0_PZ)
    # D*
    dst_d0_deltam: double; dst_M - d0_M
    dst_m: double; dst_M
    dst_p: double; GEV(dst_P)
    dst_pt: double; GEV(dst_PT)
    #dst_iso_invm: double; GEV(MINV(b0_ISOLATION_PX, b0_ISOLATION_PY, b0_ISOLATION_PZ, b0_ISOLATION_PE, dst_PX, dst_PY, dst_PZ, dst_PE))
    dst_iso_deltam: double; GEV(ISO_DELTAM(b0_ISOLATION_PX, b0_ISOLATION_PY, b0_ISOLATION_PZ, b0_ISOLATION_PE, dst_PX, dst_PY, dst_PZ, dst_PE, dst_M))
    # D0
    d0_m: double; d0_M
    d0_p: double; GEV(d0_P)
    d0_pt: double; GEV(d0_PT)
    d0_dst_veto_deltam: double; MIN(ABS(b_ISOLATION_DstWindowDELTAM-145.454), ABS(b_ISOLATION_DstWindowDELTAM2-145.454))  # MeV!
    d0_dst_veto_deltam_stub: ^double; cli_no_dst_veto; d0_dst_veto_deltam; 100.0
    # K
    k_p: double; GEV(k_P)
    k_px: double; GEV(k_PX)
    k_py: double; GEV(k_PY)
    k_pz: double; GEV(k_PZ)
    k_pt: double; GEV(k_PT)
    k_eta: double; ETA(k_P, k_PZ)
    # Pi
    pi_p: double; GEV(pi_P)
    pi_px: double; GEV(pi_PX)
    pi_py: double; GEV(pi_PY)
    pi_pz: double; GEV(pi_PZ)
    pi_pt: double; GEV(pi_PT)
    pi_eta: double; ETA(pi_P, pi_PZ)
    # slow Pi
    spi_p: double; GEV(spi_P)
    spi_px: double; GEV(spi_PX)
    spi_py: double; GEV(spi_PY)
    spi_pz: double; GEV(spi_PZ)
    spi_pt: double; GEV(spi_PT)
    spi_eta: double; ETA(spi_P, spi_PZ)
    # Mu
    mu_p: double; GEV(mu_P)
    mu_px: double; GEV(mu_PX)
    mu_py: double; GEV(mu_PY)
    mu_pz: double; GEV(mu_PZ)
    mu_pt: double; GEV(mu_PT)
    mu_eta: double; ETA(mu_P, mu_PZ)

    #################
    # PID variables #
    #################
    # Dst
    dst_id: int; dst_ID
    # D0
    d0_id: int; d0_ID
    # K
    k_is_mu: bool; k_isMuon
    k_pid_mu: double; k_PIDmu
    k_pid_k: double; k_PIDK
    k_pid_e: double; k_PIDe
    # Pi
    pi_is_mu: bool; pi_isMuon
    pi_pid_mu: double; pi_PIDmu
    pi_pid_k: double; pi_PIDK
    pi_pid_e: double; pi_PIDe
    # slow Pi
    spi_id: int; spi_ID
    spi_is_mu: bool; spi_isMuon
    spi_pid_mu: double; spi_PIDmu
    spi_pid_k: double; spi_PIDK
    spi_pid_e: double; spi_PIDe
    # Mu
    mu_id: int; mu_ID
    mu_is_mu: bool; mu_isMuon
    mu_pid_mu: double; mu_PIDmu
    mu_pid_k: double; mu_PIDK
    mu_pid_e: double; mu_PIDe
    mu_ubdt: float; mu_bdt_mu

    ######################
    # Tracking variables #
    ######################
    # B/B0
    b_endvtx_chi2ndof: double; b_ENDVERTEX_CHI2 / b_ENDVERTEX_NDOF; b0_ENDVERTEX_CHI2 / b0_ENDVERTEX_NDOF
    b_fd_trans: >-
        double;
        FD_TRANS(b_ENDVERTEX_X, b_OWNPV_X, b_ENDVERTEX_Y, b_OWNPV_Y);
        FD_TRANS(b0_ENDVERTEX_X, b0_OWNPV_X, b0_ENDVERTEX_Y, b0_OWNPV_Y)
    b_discard_mu_chi2: double; b_DISCARDMu_CHI2; b0_DISCARDMu_CHI2
    b_ndof: int; b_OWNPV_NDOF; b0_OWNPV_NDOF
    b_dira: double; b_DIRA_OWNPV; b0_DIRA_OWNPV
    # D*
    dst_endvtx_chi2ndof: double; dst_ENDVERTEX_CHI2 / dst_ENDVERTEX_NDOF
    # D0
    d0_endvtx_chi2ndof: double; d0_ENDVERTEX_CHI2 / d0_ENDVERTEX_NDOF
    d0_dira: double; d0_DIRA_OWNPV
    d0_fd_chi2: double; d0_FDCHI2_OWNPV
    d0_ip: double; d0_IP_OWNPV
    d0_ip_chi2: double; d0_IPCHI2_OWNPV
    # K
    k_gh_prob: double; k_TRACK_GhostProb
    k_ip_chi2: double; k_IPCHI2_OWNPV
    # Pi
    pi_gh_prob: double; pi_TRACK_GhostProb
    pi_ip_chi2: double; pi_IPCHI2_OWNPV
    # slow Pi
    spi_gh_prob: double; spi_TRACK_GhostProb
    spi_ip_chi2: double; spi_IPCHI2_OWNPV
    # Mu
    mu_gh_prob: double; mu_TRACK_GhostProb
    mu_ip_chi2: double; mu_IPCHI2_OWNPV

    ############################
    # Mu misID study variables #
    ############################
    # These are kept in step-1 names
    # For more consistency for the external misID unfolding program
    # which typically runs on step-1 ntuples (with friends) directly
    #
    MC15TuneV1_ProbNNpi: double; IF_VAR_EXISTS(cli_misid_study, mu_MC15TuneV1_ProbNNpi)
    MC15TuneV1_ProbNNk: double; IF_VAR_EXISTS(cli_misid_study, mu_MC15TuneV1_ProbNNk)
    MC15TuneV1_ProbNNp: double; IF_VAR_EXISTS(cli_misid_study, mu_MC15TuneV1_ProbNNp)
    MC15TuneV1_ProbNNe: double; IF_VAR_EXISTS(cli_misid_study, mu_MC15TuneV1_ProbNNe)
    MC15TuneV1_ProbNNmu: double; IF_VAR_EXISTS(cli_misid_study, mu_MC15TuneV1_ProbNNmu)
    MC15TuneV1_ProbNNghost: double; IF_VAR_EXISTS(cli_misid_study, mu_MC15TuneV1_ProbNNghost)
    DLLK: double; IF_VAR_EXISTS(cli_misid_study, mu_PIDK)
    DLLp: double; IF_VAR_EXISTS(cli_misid_study, mu_PIDp)
    DLLe: double; IF_VAR_EXISTS(cli_misid_study, mu_PIDe)
    DLLmu: double; IF_VAR_EXISTS(cli_misid_study, mu_PIDmu)
    DLLd: double; IF_VAR_EXISTS(cli_misid_study, mu_PIDd)
    IsMuon: double; IF_VAR_EXISTS(cli_misid_study, TO_TYPE(mu_isMuon, 1.0))
    InMuonAcc: double; IF_VAR_EXISTS(cli_misid_study, mu_InMuonAcc)
    #
    Brunel_MC15TuneV1_ProbNNpi: double; IF_VAR_EXISTS(cli_misid_study, mu_MC15TuneV1_ProbNNpi)
    Brunel_MC15TuneV1_ProbNNk: double; IF_VAR_EXISTS(cli_misid_study, mu_MC15TuneV1_ProbNNk)
    Brunel_MC15TuneV1_ProbNNp: double; IF_VAR_EXISTS(cli_misid_study, mu_MC15TuneV1_ProbNNp)
    Brunel_MC15TuneV1_ProbNNe: double; IF_VAR_EXISTS(cli_misid_study, mu_MC15TuneV1_ProbNNe)
    Brunel_MC15TuneV1_ProbNNmu: double; IF_VAR_EXISTS(cli_misid_study, mu_MC15TuneV1_ProbNNmu)
    Brunel_MC15TuneV1_ProbNNghost: double; IF_VAR_EXISTS(cli_misid_study, mu_MC15TuneV1_ProbNNghost)
    Brunel_DLLK: double; IF_VAR_EXISTS(cli_misid_study, mu_PIDK)
    Brunel_DLLp: double; IF_VAR_EXISTS(cli_misid_study, mu_PIDp)
    Brunel_DLLe: double; IF_VAR_EXISTS(cli_misid_study, mu_PIDe)
    Brunel_DLLmu: double; IF_VAR_EXISTS(cli_misid_study, mu_PIDmu)
    Brunel_DLLd: double; IF_VAR_EXISTS(cli_misid_study, mu_PIDd)
    Brunel_IsMuon: double; IF_VAR_EXISTS(cli_misid_study, TO_TYPE(mu_isMuon, 1.0))
    Brunel_InMuonAcc: double; IF_VAR_EXISTS(cli_misid_study, mu_InMuonAcc)
    # Binning variables
    P: double; IF_VAR_EXISTS(cli_misid_study, mu_P)
    ETA: double; IF_VAR_EXISTS(cli_misid_study, mu_eta)
    nTracks: double; IF_VAR_EXISTS(cli_misid_study, nTracks)
    # Additional kinematic variables for decay-in-flight smearing
    d0_PE: double; IF_VAR_EXISTS(cli_misid_study, d0_PE)
    d0_PX: double; IF_VAR_EXISTS(cli_misid_study, d0_PX)
    d0_PY: double; IF_VAR_EXISTS(cli_misid_study, d0_PY)
    d0_PZ: double; IF_VAR_EXISTS(cli_misid_study, d0_PZ)
    dst_M: double; IF_VAR_EXISTS(cli_misid_study, dst_M)
    dst_PE: double; IF_VAR_EXISTS(cli_misid_study, dst_PE)
    dst_PX: double; IF_VAR_EXISTS(cli_misid_study, dst_PX)
    dst_PY: double; IF_VAR_EXISTS(cli_misid_study, dst_PY)
    dst_PZ: double; IF_VAR_EXISTS(cli_misid_study, dst_PZ)
    mu_PE: double; IF_VAR_EXISTS(cli_misid_study, mu_PE)
    mu_PX: double; IF_VAR_EXISTS(cli_misid_study, mu_PX)
    mu_PY: double; IF_VAR_EXISTS(cli_misid_study, mu_PY)
    mu_PZ: double; IF_VAR_EXISTS(cli_misid_study, mu_PZ)
    b_PE: double; IF_VAR_EXISTS(cli_misid_study, b_PE)
    b_PX: double; IF_VAR_EXISTS(cli_misid_study, b_PX)
    b_PY: double; IF_VAR_EXISTS(cli_misid_study, b_PY)
    b_PZ: double; IF_VAR_EXISTS(cli_misid_study, b_PZ)
    b_ENDVERTEX_X: double; IF_VAR_EXISTS(cli_misid_study, b_ENDVERTEX_X)
    b_ENDVERTEX_Y: double; IF_VAR_EXISTS(cli_misid_study, b_ENDVERTEX_Y)
    b_ENDVERTEX_Z: double; IF_VAR_EXISTS(cli_misid_study, b_ENDVERTEX_Z)
    b_OWNPV_X: double; IF_VAR_EXISTS(cli_misid_study, b_OWNPV_X)
    b_OWNPV_Y: double; IF_VAR_EXISTS(cli_misid_study, b_OWNPV_Y)
    b_OWNPV_Z: double; IF_VAR_EXISTS(cli_misid_study, b_OWNPV_Z)
    b0_PE: double; IF_VAR_EXISTS(cli_misid_study, b0_PE)
    b0_PX: double; IF_VAR_EXISTS(cli_misid_study, b0_PX)
    b0_PY: double; IF_VAR_EXISTS(cli_misid_study, b0_PY)
    b0_PZ: double; IF_VAR_EXISTS(cli_misid_study, b0_PZ)
    b0_ENDVERTEX_X: double; IF_VAR_EXISTS(cli_misid_study, b0_ENDVERTEX_X)
    b0_ENDVERTEX_Y: double; IF_VAR_EXISTS(cli_misid_study, b0_ENDVERTEX_Y)
    b0_ENDVERTEX_Z: double; IF_VAR_EXISTS(cli_misid_study, b0_ENDVERTEX_Z)
    b0_OWNPV_X: double; IF_VAR_EXISTS(cli_misid_study, b0_OWNPV_X)
    b0_OWNPV_Y: double; IF_VAR_EXISTS(cli_misid_study, b0_OWNPV_Y)
    b0_OWNPV_Z: double; IF_VAR_EXISTS(cli_misid_study, b0_OWNPV_Z)

    #####################
    # MC true variables #
    #####################
    # D*
    dst_true_id: int; dst_TRUEID
    # D0
    d0_true_id: int; d0_TRUEID
    # FF reweighting
    ff_d_mass: >-
        double;
        SQRT(M2(
        b0_TrueHadron_D0_PX, b0_TrueHadron_D0_PY, b0_TrueHadron_D0_PZ,
        b0_TrueHadron_D0_PE)
        );
        SQRT(M2(
        b_TrueHadron_D0_PX, b_TrueHadron_D0_PY, b_TrueHadron_D0_PZ,
        b_TrueHadron_D0_PE)
        )
    ff_b_mass: >-
        double;
        SQRT(M2(b0_TRUEP_X, b0_TRUEP_Y, b0_TRUEP_Z, b0_TRUEP_E));
        SQRT(M2(b_TRUEP_X, b_TRUEP_Y, b_TRUEP_Z, b_TRUEP_E))
    q2_true: double; b0_True_Q2; b_True_Q2 # in MeV^2!
    # Inputs to Dalitz-inspired reweighting
    dd_mass: >-
        double;
        MINV2(
        b0_TrueHadron_D0_PX, b0_TrueHadron_D0_PY, b0_TrueHadron_D0_PZ, b0_TrueHadron_D0_PE,
        b0_TrueHadron_D1_PX, b0_TrueHadron_D1_PY, b0_TrueHadron_D1_PZ, b0_TrueHadron_D1_PE
        );
        MINV2(
        b_TrueHadron_D0_PX, b_TrueHadron_D0_PY, b_TrueHadron_D0_PZ, b_TrueHadron_D0_PE,
        b_TrueHadron_D1_PX, b_TrueHadron_D1_PY, b_TrueHadron_D1_PZ, b_TrueHadron_D1_PE
        )
    mx_mass: >-
        double;
        MX_MASS(
        b_TRUEP_X, b_TRUEP_Y, b_TRUEP_Z, b_TRUEP_E,
        b_TrueHadron_D0_PX, b_TrueHadron_D0_PY, b_TrueHadron_D0_PZ,b_TrueHadron_D0_PE,
        b_TrueHadron_D1_PX, b_TrueHadron_D1_PY, b_TrueHadron_D1_PZ,b_TrueHadron_D1_PE
        );
        MX_MASS(
        b0_TRUEP_X, b0_TRUEP_Y, b0_TRUEP_Z, b0_TRUEP_E,
        b0_TrueHadron_D0_PX, b0_TrueHadron_D0_PY, b0_TrueHadron_D0_PZ,b0_TrueHadron_D0_PE,
        b0_TrueHadron_D1_PX, b0_TrueHadron_D1_PY, b0_TrueHadron_D1_PZ,b0_TrueHadron_D1_PE
        )
    pair_dd_mx_mass_phoebe: >-
        ^vector<double>;
        DD_MX_MASS_DST(
        mu_MC_MOTHER_TRUEPX, mu_MC_MOTHER_TRUEPY, mu_MC_MOTHER_TRUEPZ, mu_MC_MOTHER_TRUEPE,
        dst_TRUEP_X, dst_TRUEP_Y, dst_TRUEP_Z, dst_TRUEP_E,
        mu_MC_GD_MOTHER_ID,
        mu_MC_GD_MOTHER_TRUEPX, mu_MC_GD_MOTHER_TRUEPY, mu_MC_GD_MOTHER_TRUEPZ, mu_MC_GD_MOTHER_TRUEPE,
        b0_TRUEP_X, b0_TRUEP_Y, b0_TRUEP_Z, b0_TRUEP_E
        );
        DD_MX_MASS_D0(
        mu_MC_MOTHER_TRUEPX, mu_MC_MOTHER_TRUEPY, mu_MC_MOTHER_TRUEPZ, mu_MC_MOTHER_TRUEPE,
        d0_MC_MOTHER_TRUEPX, d0_MC_MOTHER_TRUEPY, d0_MC_MOTHER_TRUEPZ, d0_MC_MOTHER_TRUEPE,
        mu_MC_GD_MOTHER_ID,
        mu_MC_GD_MOTHER_TRUEPX, mu_MC_GD_MOTHER_TRUEPY, mu_MC_GD_MOTHER_TRUEPZ, mu_MC_GD_MOTHER_TRUEPE,
        d0_TRUEP_X, d0_TRUEP_Y, d0_TRUEP_Z, d0_TRUEP_E, d0_MC_MOTHER_ID,
        b_TRUEP_X, b_TRUEP_Y, b_TRUEP_Z, b_TRUEP_E
        )
    dd_mass_phoebe: double; EXTRACT_ELEM(pair_dd_mx_mass_phoebe, 0)
    mx_mass_phoebe: double; EXTRACT_ELEM(pair_dd_mx_mass_phoebe, 1)

    ################################
    # Selection flags, MC-specific #
    ################################
    # Truth-matching
    mc_id: int; cli_mc_id
    truthmatch: >-
        int;
        MC_TRUTH_MATCH_DST(
        mc_id,
        mu_TRUEID, mu_MC_MOTHER_ID, mu_MC_GD_MOTHER_ID, mu_MC_GD_GD_MOTHER_ID,
        mu_MC_MOTHER_KEY, mu_MC_GD_MOTHER_KEY, mu_MC_GD_GD_MOTHER_KEY,
        dst_MC_MOTHER_ID, dst_MC_GD_MOTHER_ID, dst_MC_GD_GD_MOTHER_ID,
        dst_MC_MOTHER_KEY, dst_MC_GD_MOTHER_KEY, dst_MC_GD_GD_MOTHER_KEY,
        dst_MC_MOTHER_TRUEPE, dst_MC_MOTHER_TRUEPX, dst_MC_MOTHER_TRUEPY, dst_MC_MOTHER_TRUEPZ,
        dst_TRUEP_E, dst_TRUEP_X, dst_TRUEP_Y, dst_TRUEP_Z,
        dst_BKGCAT, d0_BKGCAT, b0_BKGCAT
        );
        MC_TRUTH_MATCH_D0(
        mc_id, b_TRUEID,
        mu_TRUEID, mu_MC_MOTHER_ID, mu_MC_GD_MOTHER_ID, mu_MC_GD_GD_MOTHER_ID, mu_MC_GD_GD_GD_MOTHER_ID,
        mu_MC_MOTHER_KEY, mu_MC_GD_MOTHER_KEY, mu_MC_GD_GD_MOTHER_KEY, mu_MC_GD_GD_GD_MOTHER_KEY,
        d0_MC_MOTHER_ID, d0_MC_GD_MOTHER_ID, d0_MC_GD_GD_MOTHER_ID, d0_MC_GD_GD_GD_MOTHER_ID,
        d0_MC_MOTHER_KEY, d0_MC_GD_MOTHER_KEY, d0_MC_GD_GD_MOTHER_KEY, d0_MC_GD_GD_GD_MOTHER_KEY,
        d0_TRUEP_E, d0_TRUEP_X, d0_TRUEP_Y, d0_TRUEP_Z,
        d0_MC_MOTHER_TRUEPE, d0_MC_MOTHER_TRUEPX, d0_MC_MOTHER_TRUEPY, d0_MC_MOTHER_TRUEPZ,
        d0_MC_GD_MOTHER_TRUEPE, d0_MC_GD_MOTHER_TRUEPX, d0_MC_GD_MOTHER_TRUEPY, d0_MC_GD_MOTHER_TRUEPZ,
        b_BKGCAT
        )
    is_ddx: bool; IS_DDX(mc_id)
    # this is a naive filter:
    # we require the 2nd daughter of B is also a D meson for DDX MC only
    ddx_add_truthmatch: >-
        bool;
        is_ddx && HUNDREDS_DIGIT(b0_TrueHadron_D1_ID) == 4;
        is_ddx && HUNDREDS_DIGIT(b_TrueHadron_D1_ID) == 4
    is_strange: bool; IS_STRANGE(mc_id)

    # FF reweighting
    # NOTE: Need to have a valid HAMMER weight unless is a DDX or D**s
    ham_ok: bool; ham_ok; true

    ##########################
    # Selection flags, basic #
    ##########################
    # Trigger
    # NOTE: For MC, L0 are applied as weight, and HLT2 is already applied at DV level
    l0: >-
        bool; IF_VAR_EXISTS(mc_id, true); b_l0_global_tis || d0_l0_hadron_tos
    hlt1: >-
        bool;
        k_hlt1_trackmva_tos_emu || pi_hlt1_trackmva_tos_emu || d0_hlt1_twotrackmva_tos_emu;
        k_hlt1_trackmva_tos || pi_hlt1_trackmva_tos || d0_hlt1_twotrackmva_tos
    hlt2: >-
        bool;
        IF_VAR_EXISTS(mc_id, true);
        IF_VAR_EXISTS(cli_misid, b_hlt2_fakeline_tos);
        IF_VAR_EXISTS(cli_misid_study, b_hlt2_fakeline_tos);
        b_hlt2_tos

    # D0 selection
    d0_pid_ok: >-
        bool;
        IF_VAR_EXISTS(mc_id, true);
        FLAG_SEL_D0_PID_OK_RUN1(k_PIDK, pi_PIDK, k_isMuon, pi_isMuon)
    d0_pid_ok_stub: ^bool; cli_cutflow; d0_pid_ok
    # Note that the EMULATED trigger lines take precedence.
    d0_ok: >-
        bool;
        FLAG_SEL_D0_RUN1(
        d0_pid_ok_stub,
        k_PT, pi_PT,
        k_hlt1_trackmva_tos_emu, pi_hlt1_trackmva_tos_emu,
        k_IPCHI2_OWNPV, pi_IPCHI2_OWNPV,
        k_TRACK_GhostProb, pi_TRACK_GhostProb,
        d0_PT,
        true,
        d0_ENDVERTEX_CHI2, d0_ENDVERTEX_NDOF,
        d0_IP_OWNPV, d0_IPCHI2_OWNPV,
        d0_DIRA_OWNPV,
        d0_FDCHI2_OWNPV
        );
        FLAG_SEL_D0_RUN1(
        d0_pid_ok_stub,
        k_PT, pi_PT,
        k_Hlt1TrackMVADecision_TOS, pi_Hlt1TrackMVADecision_TOS,
        k_IPCHI2_OWNPV, pi_IPCHI2_OWNPV,
        k_TRACK_GhostProb, pi_TRACK_GhostProb,
        d0_PT,
        true,
        d0_ENDVERTEX_CHI2, d0_ENDVERTEX_NDOF,
        d0_IP_OWNPV, d0_IPCHI2_OWNPV,
        d0_DIRA_OWNPV,
        d0_FDCHI2_OWNPV
        )
    d0_m_ok: bool; FLAG_SEL_D0_MASS(d0_M)
    d0_m_hypo_ok: bool; FLAG_SEL_D0_MASS_HYPO(mu_PX, mu_PY, mu_PZ, d0_PX, d0_PY, d0_PZ, d0_M)

    # Mu selection
    # Variables needed for Mu selection
    trk_mu:  ^XYZVector; XYZVector(mu_PX, mu_PY, mu_PZ)
    trk_k:   ^XYZVector; XYZVector(k_PX, k_PY, k_PZ)
    trk_pi:  ^XYZVector; XYZVector(pi_PX, pi_PY, pi_PZ)
    trk_spi: ^XYZVector; XYZVector(spi_PX, spi_PY, spi_PZ)
    trks_other: ^vector<XYZVector>; BUILD_VEC(trk_k, trk_pi, trk_spi); BUILD_VEC(trk_k, trk_pi)
    # Actual flags
    trks_ok: bool; FLAG_SEL_GOOD_TRACKS(trk_mu, trks_other)
    mu_pid_ok: >-
        bool;
        IF_VAR_EXISTS(mc_id, true);
        IF_VAR_EXISTS(cli_misid, true);
        IF_VAR_EXISTS(cli_misid_study, true);
        FLAG_SEL_MU_PID_OK_RUN1(mu_isMuon, mu_PIDmu, mu_PIDe)
    mu_pid_ok_stub: ^bool; cli_cutflow; mu_pid_ok
    mu_ubdt_ok: bool; mu_ubdt > 0.25; true
    mu_ubdt_veto: bool; mu_ubdt < 0.25; true

    mu_ok: >-
        bool; FLAG_SEL_MU_RUN1(
        mu_pid_ok_stub, trks_ok,
        mu_P, mu_eta,
        mu_IPCHI2_OWNPV, mu_TRACK_GhostProb
        )

    # D0Mu combo selection
    d0_dst_veto_ok: bool; d0_dst_veto_deltam > 4.0
    d0mu_ok: >-
        bool; FLAG_SEL_BMINUSD0_RUN1(
        d0_ok, mu_ok,
        b_ENDVERTEX_CHI2, b_ENDVERTEX_NDOF,
        b_fd_trans,
        b_DIRA_OWNPV,
        d0_dst_veto_deltam_stub
        )

    # D*Mu combo selection
    # NOTE: The 'b_fd_trans' and 'b_discard_mu_chi2' are step-2 vars defined in this YAML,
    #       and they have the same names for B/B0 trees
    dstmu_ok: >-
        bool; FLAG_SEL_B0DST_RUN1(
        d0_ok, mu_ok,
        spi_TRACK_GhostProb,
        dst_ENDVERTEX_CHI2, dst_ENDVERTEX_NDOF,
        b_discard_mu_chi2,
        b0_ENDVERTEX_CHI2, b0_ENDVERTEX_NDOF,
        b_fd_trans,
        b0_DIRA_OWNPV
        )
    dst_m_ok: bool; FLAG_SEL_DST_MASS(dst_m, d0_m)

    ###############################
    # Selection flags, additional #
    ###############################
    dx_m_ok: bool; d0_m_ok && dst_m_ok; d0_m_ok && d0_m_hypo_ok && d0_dst_veto_ok
    ####
    in_fit_range: bool; IN_RANGE(mm2, -2.0, 10.9) && IN_RANGE(el, 0.1, 2.65) && IN_RANGE(q2, -0.4, 12.6)
    in_fit_range_smr_k: bool; IN_RANGE(mm2_smr_k, -2.0, 10.9) && IN_RANGE(el_smr_k, 0.1, 2.65) && IN_RANGE(q2_smr_k, -0.4, 12.6)
    in_fit_range_smr_pi: bool; IN_RANGE(mm2_smr_pi, -2.0, 10.9) && IN_RANGE(el_smr_pi, 0.1, 2.65) && IN_RANGE(q2_smr_pi, -0.4, 12.6)
    in_fit_range_no_smr: bool; in_fit_range
    ####
    b_m_ok: bool; FLAG_SEL_B0_MASS(b0_M); FLAG_SEL_BMINUS_MASS(b_M)
    b_m_ok_smr_k: bool; IF_VAR_EXISTS(b0_M, FLAG_SEL_B0_MASS(b_m_smr_k)); FLAG_SEL_BMINUS_MASS(b_m_smr_k)
    b_m_ok_smr_pi: bool; IF_VAR_EXISTS(b0_M, FLAG_SEL_B0_MASS(b_m_smr_pi)); FLAG_SEL_BMINUS_MASS(b_m_smr_pi)
    b_m_ok_no_smr: bool; b_m_ok
    ####
    b_m_sb: bool; FLAG_SEL_B0_MASS_SB(b0_M); FLAG_SEL_BMINUS_MASS_SB(b_M)
    b_m_sb_smr_k: bool; IF_VAR_EXISTS(b0_M, FLAG_SEL_B0_MASS_SB(b_m_smr_k)); FLAG_SEL_BMINUS_MASS_SB(b_m_smr_k)
    b_m_sb_smr_pi: bool; IF_VAR_EXISTS(b0_M, FLAG_SEL_B0_MASS_SB(b_m_smr_pi)); FLAG_SEL_BMINUS_MASS_SB(b_m_smr_pi)
    b_m_sb_no_smr: bool; b_m_sb
    ####

    #########
    # Skims #
    #########
    # don't require 'mu_ubdt_ok' as this YAML applies to misID ntuples too
    skim_global_ok: bool; dx_m_ok && b_m_ok && in_fit_range
    skim_global_ok_smr_k: bool; dx_m_ok && b_m_ok_smr_k && in_fit_range_smr_k
    skim_global_ok_smr_pi: bool; dx_m_ok && b_m_ok_smr_pi && in_fit_range_smr_pi
    skim_global_ok_no_smr: bool; skim_global_ok
    ####
    skim_global_usb: bool; dx_m_ok && b_m_sb
    skim_global_usb_smr_k: bool; dx_m_ok && b_m_sb_smr_k
    skim_global_usb_smr_pi: bool; dx_m_ok && b_m_sb_smr_pi
    skim_global_usb_no_smr: bool; skim_global_usb
    ####
    is_iso: bool; skim_global_ok && is_iso_loose
    is_dd: bool; skim_global_ok && is_dd_loose
    is_2os: bool; skim_global_ok && is_2os_loose
    is_1os: bool; skim_global_ok && is_1os_loose
    is_prot: bool; skim_global_ok && is_prot_loose

    is_iso_loose: bool; FLAG_ISO(true, iso_bdt1)
    is_dd_loose: >-
        bool; FLAG_DD(
        true,
        iso_bdt1, iso_bdt2, iso_bdt3, iso_type1, iso_type2, iso_type3,
        iso_p1, iso_p2, iso_p3, iso_pt1, iso_pt2, iso_pt3,
        iso_nnk1, iso_nnk2, iso_nnk3
        )
    is_2os_loose: >-
        bool; FLAG_2OS(
        true,
        iso_bdt1, iso_bdt2, iso_bdt3, iso_type1, iso_type2,
        iso_p1, iso_p2, iso_pt1, iso_pt2,
        iso_chrg1, iso_chrg2,
        iso_nnk1, iso_nnk2
        )
    is_1os_loose: >-
        bool;
        FLAG_1OS(
        true,
        iso_bdt1, iso_bdt2, iso_type1,
        iso_p1, iso_pt1,
        iso_chrg1,
        iso_nnk1,
        dst_id, dst_iso_deltam
        );
        FLAG_1OS(
        true,
        iso_bdt1, iso_bdt2, iso_type1,
        iso_p1, iso_pt1,
        iso_chrg1,
        iso_nnk1,
        d0_id
        )
    is_prot_loose: >-
        bool;
        FLAG_PROT(
        true,
        iso_bdt1, iso_bdt2, iso_type1,
        iso_p1, iso_pt1,
        iso_chrg1,
        iso_nnp1,
        d0_id
        )

    ###########
    # Weights #
    ###########
    # Branching fraction weights for DD MC
    wbr_dd: double; IF(is_ddx, WT_DD_BF(mu_MC_MOTHER_ID), 1.0)
    # Dalitz-inspired variational weights for DD MC
    tmp_dal: ^vector<double>; WT_DALITZ(dd_mass, b0_TRUEID); WT_DALITZ(dd_mass, b_TRUEID)
    tmp_dal_phoebe: ^vector<double>; WT_DALITZ(dd_mass_phoebe, b0_TRUEID); WT_DALITZ(dd_mass_phoebe, b_TRUEID)
    wdal_lp: double; EXTRACT_ELEM(tmp_dal, 0)
    wdal_lm: double; EXTRACT_ELEM(tmp_dal, 1)
    wdal_qp: double; EXTRACT_ELEM(tmp_dal, 2)
    wdal_qm: double; EXTRACT_ELEM(tmp_dal, 3)
    wdal_phoebe_lp: double; EXTRACT_ELEM(tmp_dal_phoebe, 0)
    wdal_phoebe_lm: double; EXTRACT_ELEM(tmp_dal_phoebe, 1)
    wdal_phoebe_qp: double; EXTRACT_ELEM(tmp_dal_phoebe, 2)
    wdal_phoebe_qm: double; EXTRACT_ELEM(tmp_dal_phoebe, 3)

    # K/K* variation weights (these weight up/down the K* events)
    # NOTE: Here the 'minus' component means highter weight for D*
    #       This is to be consistent w/ Phoebe's
    #       It's an intentional sign error
    is_kst: bool; IF(mx_mass > 620, true, false)
    wkst_m: double; IF(is_kst, 0.0, 1.0)
    wkst_p: double; IF(is_kst, 2.0, 1.0)
    is_kst_phoebe: bool; IF(mx_mass_phoebe > 620, true, false)
    wkst_phoebe_m: double; IF(is_kst_phoebe, 0.0, 1.0)
    wkst_phoebe_p: double; IF(is_kst_phoebe, 2.0, 1.0)

    # Phenomenological correction based on true q2 in D** heavy
    wq2p: double; 1 + 2*(((q2_true - 105*105)/8e6) - 0.5)
    wq2m: double; 1 - 2*(((q2_true - 105*105)/8e6) - 0.5)

    # misID weights
    in_deltam_sb: "^bool; d0_m_ok && !dst_m_ok"
    # 'wmis' is the NON-DiF-SMEARED misID weights
    wmis: >-
        double;
        wmis_norm*skim_global_ok +
        wmis_bsb*(dx_m_ok && b_m_sb) +
        wmis_dsb*(in_deltam_sb && b_m_ok && in_fit_range) +
        wmis_dsb_bsb*(in_deltam_sb && b_m_sb);
        wmis_norm*skim_global_ok + wmis_bsb*(dx_m_ok && b_m_sb)
    wmis_smr_k: >-
        double;
        wmis*(wmis_norm_smr_k*skim_global_ok_smr_k +
        wmis_bsb_smr_k*(dx_m_ok && b_m_sb) +
        wmis_dsb_smr_k*(in_deltam_sb && b_m_ok && in_fit_range_smr_k) +
        wmis_dsb_bsb_smr_k*(in_deltam_sb && b_m_sb)
        );
        wmis*(wmis_norm_smr_k*skim_global_ok_smr_k + wmis_bsb_smr_k*(dx_m_ok && b_m_sb))
    wmis_smr_pi: >-
        double;
        wmis*(wmis_norm_smr_pi*skim_global_ok_smr_pi +
        wmis_bsb_smr_pi*(dx_m_ok && b_m_sb) +
        wmis_dsb_smr_pi*(in_deltam_sb && b_m_ok && in_fit_range_smr_pi) +
        wmis_dsb_bsb_smr_pi*(in_deltam_sb && b_m_sb)
        );
        wmis*(wmis_norm_smr_pi*skim_global_ok_smr_pi + wmis_bsb_smr_pi*(dx_m_ok && b_m_sb))
    wmis_no_smr: >-
        double;
        wmis*(wmis_norm_no_smr*skim_global_ok_no_smr +
        wmis_bsb_no_smr*(dx_m_ok && b_m_sb) +
        wmis_dsb_no_smr*(in_deltam_sb && b_m_ok && in_fit_range_no_smr) +
        wmis_dsb_bsb_no_smr*(in_deltam_sb && b_m_sb)
        );
        wmis*(wmis_norm_no_smr*skim_global_ok_no_smr + wmis_bsb_no_smr*(dx_m_ok && b_m_sb))

    # Weight representing the global cut (BEFORE applying the skim cuts)
    wpid_base: ^double; wpid_k*wpid_pi
    wpid: double; wpid_base*wpid_mu                      # PID w/o UBDT, typically unused
    wpid_ubdt: double; wpid_base*wpid_mu_ubdt            # PID w/ UBDT
    wpid_ubdt_veto: double; wpid_base*wpid_mu_ubdt_veto  # PID w/ UBDT veto
    ####
    wtrg_l0_tis: ^double; b0_l0_global_tis_emu; b_l0_global_tis_emu
    wtrg: float; d0_l0_hadron_tos_emu + wtrg_l0_tis - d0_l0_hadron_tos_emu*wtrg_l0_tis
    wtrk: double; wtrk_k*wtrk_pi*wtrk_mu*wtrk_spi; wtrk_k*wtrk_pi*wtrk_mu
    wjk: double; wjk_kin*wjk_occ

    w_base: double; wtrg*wtrk*wjk*wbr_dd          # no PID cuts for the base weights
    w_w_ubdt: double; w_base*wpid_ubdt            # default PID cuts incl. UBDT
    w_w_ubdt_veto: double; w_base*wpid_ubdt_veto  # misID validation sample maybe
    wff: double; wff; 1.0                         # FF weight. default to 1
    w: double; w_w_ubdt*wff                       # form factor weights last
    # Skim weights, including the 'w'
    wiso: double; w*wskim_iso*skim_global_ok; TO_TYPE(is_iso, 1.0)
    wdd: double; w*wskim_dd*skim_global_ok; TO_TYPE(is_dd, 1.0)
    w2os: double; w*wskim_2os*skim_global_ok; TO_TYPE(is_2os, 1.0)
    w1os: double; w*wskim_1os*skim_global_ok; TO_TYPE(is_1os, 1.0)
    wprot: double; TO_TYPE(is_prot, 1.0)  # TODO: Add PIDCalib weights for MC

    # PID for isolation tracks
    wpid_iso_nnk1_gt: >-
        double;
        WT_ISO_NNK(iso_true_id1,
        wpid_iso_nnk1_gt_pi, wpid_iso_nnk1_gt_k, wpid_iso_nnk1_gt_p,
        wpid_iso_nnk1_gt_e, wpid_iso_nnk1_gt_mu, wpid_iso_nnk1_gt_g
        )
    wpid_iso_nnk2_gt: >-
        double;
        WT_ISO_NNK(iso_true_id2,
        wpid_iso_nnk2_gt_pi, wpid_iso_nnk2_gt_k, wpid_iso_nnk2_gt_p,
        wpid_iso_nnk2_gt_e, wpid_iso_nnk2_gt_mu, wpid_iso_nnk2_gt_g
        )
    wpid_iso_nnk3_gt: >-
        double;
        WT_ISO_NNK(iso_true_id3,
        wpid_iso_nnk3_gt_pi, wpid_iso_nnk3_gt_k, wpid_iso_nnk3_gt_p,
        wpid_iso_nnk3_gt_e, wpid_iso_nnk3_gt_mu, wpid_iso_nnk3_gt_g
        )
    wpid_iso_nnk1_lt: double; 1 - wpid_iso_nnk1_gt
    wpid_iso_nnk2_lt: double; 1 - wpid_iso_nnk2_gt
    wpid_iso_nnk3_lt: double; 1 - wpid_iso_nnk3_gt

    # Skims, but in weights, for MC
    wskim_iso: double; WT_ISO(true, iso_bdt1)
    wskim_dd: >-
        double; WT_DD(
        true,
        iso_bdt1, iso_bdt2, iso_bdt3, iso_type1, iso_type2, iso_type3,
        iso_p1, iso_p2, iso_p3, iso_pt1, iso_pt2, iso_pt3,
        wpid_iso_nnk1_gt, wpid_iso_nnk2_gt, wpid_iso_nnk3_gt
        )
    wskim_2os: >-
        double; WT_2OS(
        true,
        iso_bdt1, iso_bdt2, iso_bdt3, iso_type1, iso_type2,
        iso_p1, iso_p2, iso_pt1, iso_pt2,
        iso_chrg1, iso_chrg2,
        wpid_iso_nnk1_lt, wpid_iso_nnk2_lt
        )
    wskim_1os: >-
        bool;
        WT_1OS(
        true,
        iso_bdt1, iso_bdt2,
        iso_type1,
        iso_p1, iso_pt1,
        iso_chrg1,
        wpid_iso_nnk1_lt,
        dst_id, dst_iso_deltam
        );
        WT_1OS(
        true,
        iso_bdt1, iso_bdt2,
        iso_type1,
        iso_p1, iso_pt1,
        iso_chrg1,
        wpid_iso_nnk1_lt,
        d0_id
        )

    ###############
    # Global cuts #
    ###############
    # These are defined so that we can turn them on/off with external variables
    # supplied in babymaker cli arguments
    trg_ok: bool; cli_cutflow; l0 && hlt1 && hlt2
    global_cut_ok: bool; cli_cutflow; dstmu_ok; d0mu_ok

global_selection:
    - trg_ok
    - global_cut_ok
    - truthmatch > 0
    - "!is_ddx || ddx_add_truthmatch && dd_mass_phoebe > 1000*1000"  # kill the leaking false DD events
    - ham_ok

one_cand_only:
    enable: true
    branch: calculation_prs_in

global_mute:
    - ".*_true.*"
    - "w.*"
    - "mc_.*"
    - "ff_.*"
    - truthmatch
    - is_ddx
    - is_strange
    - ham_ok
    - P
    - ETA
    - nTracks
    - IsMuon
    - InMuonAcc
    - "MC15TuneV1_ProbNN.*"
    - "DLL.*"
    - "b_M"
    - "b_P.*"
    - "b?_OWNPV.*"
    - "b?_ENDVERTEX.*"
    - "FitVar_.*"
    - ".*_M"
    - "iso_nn.*"
    - ".*_is_.*"
    - ".*_pid_.*"
    - "is_(iso|dd|1os|2os|prot)(_loose)?"
    - "(dd|mx|pair_dd_mx)_mass(_phoebe)?"
    - "is_kst(_phoebe)?"
    - "in_(deltam|deltam_sb)"
    - "tmp_(dal|dal_phoebe)"
    - ".*_smr_(k|pi)"
    - ".*_no_smr"

output:
    Dst:
        input: TupleB0/DecayTree
        mute:
            - "d0_dst_veto_deltam"
            - "d0_dst_veto_ok"
            - "d0mu_ok"
    D0:
        input: TupleBminus/DecayTree
        mute:
            - "^spi_.*"
            - "^dst_.*"
            - "trk_spi"
            - "dstmu_ok"

    Dst_ws_Mu:
        input: TupleB0WSMu/DecayTree
        mute:
            - "d0_dst_veto_deltam"
            - "d0_dst_veto_ok"
            - "d0mu_ok"
    Dst_ws_Pi:
        input: TupleB0WSPi/DecayTree
        mute:
            - "d0_dst_veto_deltam"
            - "d0_dst_veto_ok"
            - "d0mu_ok"
    D0_ws_Mu:
        input: TupleBminusWS/DecayTree
        mute:
            - "^spi_.*"
            - "^dst_.*"
            - "trk_spi"
            - "dstmu_ok"
