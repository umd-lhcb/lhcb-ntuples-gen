# This YAML is for Phoebe's step-1 and step-1.5 D* ntuples.
# After postprocessing, the ntuple should be mostly identical to our step-2.
#
# NOTE: We don't have the following branches in Phoebe's step-1.5.
#
# - k_ip_chi2, pi_ip_chi2 (_IPCHI2_OWNPV)
# - k_gh_prob, pi_gh_prob (_TRACK_GhostProb)
# - d0_endvtx_chi2, d0_endvtx_ndof (_ENDVERTEX_{CHI2/NDOF})
# - d0_fd_chi2 (D0_FDCHI2_OWNPV)
# - dst_endvtx_ndof (D0_ENDVERTEX_NDOF)
# - Most of the momentum components
# - b_endvtx_ndof (Y_ENDVERTEX_NDOF)
#
# In postprocessed step-2 ntuples these are filled with default values that
# satisfy cut requirements.

headers:
    user:
        - functor/rdx/cut.h
        - functor/rdx/skims.h
        - functor/rdx/kinematic.h
        - functor/rdx/flag.h
        - functor/basic.h

keep:
    # For event matching
    - runNumber
    - eventNumber

rename:
    # General
    Polarity: polarity
    runNumber: run
    eventNumber: event
    # L0
    YTIS: b0_l0_global_tis
    YTOS: d0_l0_hadron_tos
    L0: mu_l0_global_tis
    # HLT1
    Hlt1TAL0K: k_hlt1_tal0_tos  # TrackAllL0Decision
    Hlt1TAL0pi: pi_hlt1_tal0_tos
    Hlt1: dst_hlt1_phys_tos
    # HLT2
    Hlt2: d0_hlt2_tos  # Hlt2CharmHadD02HH_D02KPiDecision


calculation:
    # For pseudo-random sequence generation
    prs_in: double; Y_PT

    #######################
    # Isolation variables #
    #######################
    # Isolation BDTs
    iso_bdt1: double; iso_BDT
    iso_bdt2: double; iso_BDT2
    iso_bdt3: double; iso_BDT3
    # PID
    iso_nnk1: float; iso_NNk
    iso_nnk2: float; iso_NNk2
    iso_nnk3: float; iso_NNk3
    # Charge
    iso_chrg1: int; TO_TYPE(iso_CHARGE, 1)
    iso_chrg2: int; TO_TYPE(iso_CHARGE2, 1)
    # Kinematic
    iso_p1: float; GEV(iso_P)
    iso_p2: float; GEV(iso_P2)
    iso_p3: float; GEV(iso_P3)
    iso_pt1: float; GEV(iso_PT)
    iso_pt2: float; GEV(iso_PT2)
    iso_pt3: float; GEV(iso_PT3)
    # Track types
    iso_type1: int; TO_TYPE(iso_Type, 1)
    iso_type2: int; TO_TYPE(iso_Type2, 1)
    iso_type3: int; TO_TYPE(iso_Type3, 1)

    #################
    # Fit variables #
    #################
    el: double; GEV(El)
    mm2: double; m_nu1  # in GeV already
    q2: double; GEV2(q2)

    #######################
    # Kinematic variables #
    #######################
    # B0
    b0_m: double; GEV(Y_M)
    b0_p: double; GEV(Y_P)
    b0_pt: double; GEV(Y_PT)
    # D*
    dst_m: double; GEV(Dst_M)
    dst_p: double; GEV(Dst_P)
    dst_pt: double; GEV(Dst_PT)
    dst_iso_invm: double; 0.0  # Not implemented by Phoebe; Greg only
    dst_iso_deltam: double; GEV(iso_DeltaM)
    # D0
    d0_m: double; GEV(D0_M)
    d0_p: double; GEV(D0_P)
    d0_pt: double; GEV(D0_PT)
    # K
    k_p: double; GEV(K_P)
    k_pt: double; GEV(K_PT)
    # Pi
    pi_p: double; GEV(pi_P)
    pi_pt: double; GEV(pi_PT)
    # Mu
    mu_p: double; GEV(mu_P)
    mu_pt: double; GEV(mu_PT)

    #################
    # PID variables #
    #################
    # Dst
    dst_id: int; Dst_ID
    # D0
    d0_id: int; SIGN(dst_id)*421  # Faked from D* ID
    # K
    k_pid_k: double; KPID
    # Pi
    pi_pid_k: double; piPID
    # Mu
    mu_is_mu: bool; mu_is
    mu_pid_mu: double; DLLmu
    mu_pid_e: double; DLLe
    mu_ubdt: float; BDTmu  # Greg's Mu UBDT PID

    ######################
    # Tracking variables #
    ######################
    # B0
    b0_endvtx_chi2: double; Y_ENDVERTEX_CHI2
    b0_endvtx_ndof: double; 1000.0
    b0_dira: double; Y_DIRA_OWNPV
    b0_fd_trans: double; dxy
    b0_discard_mu_chi2: double; Y_DISCARDMu_CHI2
    # D*
    dst_endvtx_chi2: double; Dst_ENDVERTEX_CHI2
    dst_endvtx_ndof: double; 1000.0
    # D0
    d0_endvtx_chi2: double; 0.0
    d0_endvtx_ndof: double; 1.0
    d0_dira: double; D0_DIRA_OWNPV
    d0_fd_chi2: double; 500.0
    d0_ip: double; D0IP
    d0_ip_chi2: double; D0IPCHI2
    # K
    k_is_mu: bool; muVeto
    k_gh_prob: double; 0.0
    k_ip_chi2: double; KIPCHI2
    # Pi
    pi_is_mu: bool; muVeto
    pi_gh_prob: double; 0.0
    pi_ip_chi2: double; piIPCHI2
    # Slow Pi
    spi_gh_prob: double; pislow_GhostProb
    spi_trk_type: int; piminus_TRACK_Type
    # Mu
    mu_gh_prob: double; 0.0  # GhostProb <- mu_ProbNNghost, which is not TRACK_GhostProb
    mu_ip_chi2: double; muIPCHI2
    mu_eta: double; mu_ETA

    ###################
    # Selection flags #
    ###################
    # Misc.
    is_data: bool; isData
    is_std: bool; is_data && DstIDprod > 0 && IDprod > 0
    is_2011: bool; flag2011

    # Trigger
    l0: bool; mu_l0_global_tis && (b0_l0_global_tis || d0_l0_hadron_tos)
    hlt1: bool; (k_hlt1_tal0_tos || pi_hlt1_tal0_tos) && dst_hlt1_phys_tos
    hlt2: bool; d0_hlt2_tos

    # D0 selection
    d0_pid_ok: bool; FLAG_SEL_D0_PID_OK_RUN1(k_pid_k, pi_pid_k, muVeto, muVeto)
    d0_ok: >-
        bool; FLAG_SEL_D0_RUN1(
        d0_pid_ok,
        K_PT, pi_PT,
        k_hlt1_tal0_tos, pi_hlt1_tal0_tos,
        k_ip_chi2, pi_ip_chi2,
        k_gh_prob, pi_gh_prob,
        D0_PT,
        d0_hlt2_tos,
        d0_endvtx_chi2, d0_endvtx_ndof,
        d0_ip, d0_ip_chi2,
        d0_dira,
        d0_fd_chi2,
        D0_M
        )

    # Mu selection
    trks_ok: bool; true
    mu_pid_ok: bool; FLAG_SEL_MU_PID_OK_RUN1(mu_is_mu, mu_pid_mu, mu_pid_e)
    mu_ubdt_ok: bool; mu_ubdt > 0.25
    mu_ok: >-
        bool; FLAG_SEL_MU_RUN1(
        mu_pid_ok, trks_ok,
        mu_P, mu_eta,
        mu_ip_chi2, mu_gh_prob
        )

    # D*Mu combo selection
    dstmu_ok: >-
        bool; FLAG_SEL_B0DST_RUN1(
        d0_ok, mu_ok,
        spi_gh_prob,
        dst_endvtx_chi2, dst_endvtx_ndof,
        Dst_M, D0_M,
        b0_discard_mu_chi2,
        b0_endvtx_chi2, b0_endvtx_ndof,
        b0_fd_trans,
        b0_dira, Y_M
        )

    # Skims
    is_iso: bool; FLAG_ISO(mu_ubdt_ok && ISOnum == 0, iso_bdt1)
    is_dd: >-
        bool; FLAG_DD(
        mu_ubdt_ok && AntiISOnum == 0,
        iso_bdt1, iso_bdt2, iso_bdt3,
        iso_type1, iso_type2, iso_type3,
        iso_p1, iso_p2, iso_p3,
        iso_pt1, iso_pt2, iso_pt3,
        iso_nnk1, iso_nnk2, iso_nnk3
        )
    is_2os: >-
        bool; FLAG_2OS(
        mu_ubdt_ok && AntiISOnum == 0,
        iso_bdt1, iso_bdt2, iso_bdt3,
        iso_type1, iso_type2,
        iso_p1, iso_p2,
        iso_pt1, iso_pt2,
        iso_chrg1, iso_chrg2,
        iso_nnk1, iso_nnk2
        )
    is_1os: >-
        bool; FLAG_1OS(
        mu_ubdt_ok && AntiISOnum == 0,
        iso_bdt1, iso_bdt2,
        iso_type1,
        iso_p1, iso_pt1,
        iso_chrg1,
        iso_nnk1,
        dst_id, dst_iso_deltam
        )

    ####################
    # Additional flags #
    ####################
    is_dst_sb: bool; ABS(Dst_M-D0_M-145.454-9) < 2.0

    ###############
    # Global cuts #
    ###############
    # These are defined so that we can turn them on/off with external variables
    # supplied in babymaker cli arguments
    trg_ok: bool; cli_cutflow; l0 && hlt1 && hlt2
    global_cut_ok: bool; cli_cutflow; dstmu_ok

global_selection:
    - trg_ok
    - global_cut_ok
    # Cuts on fit variables
    - IN_RANGE(mm2, -2.0, 10.9)
    - IN_RANGE(el, 0.1, 2.65)
    - IN_RANGE(q2, -0.4, 12.6)
    # Remove VELO slow Pi
    - spi_trk_type == 3
    # Some weight cut
    - reweighting_69_gen3_pt2 >= 0.01 && reweighting_89_gen3_pt2 >= 0.01

one_cand_only:
    enable: true
    branch: calculation_prs_in

output:
    Dst_data:
        input: ntp1
        selection:
            - is_std  # Signature for 'std' reconstruction mode
